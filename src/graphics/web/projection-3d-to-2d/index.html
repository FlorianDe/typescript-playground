<html>

<head>
    <style>
        html,
        body {
            border: none;
            margin: 0;
            padding: 0;
        }

        body {
            background-color: dimgray;
        }

        .centerContent {
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #canvas {
            border-radius: 6px;
            border: 2px solid gray;
            background-color: white;
        }
    </style>
</head>

<body>
    <div class="centerContent">
        <canvas id="canvas"></canvas>
    </div>
</body>
<script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const ASPECT_RATIO_WIDTH_TO_HEIGHT = 1;

    const resizeCanvas = () => {
        const scale = Math.min(window.innerWidth * 0.95 / ASPECT_RATIO_WIDTH_TO_HEIGHT, window.innerHeight * 0.95);
        canvas.width = scale * ASPECT_RATIO_WIDTH_TO_HEIGHT;
        canvas.height = scale;
    };

    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    const POINT_SIZE = 20;
    const STROKE_WIDTH = 6;
    const points = [
        { x: -0.5, y: -0.5, z: 0.5 },
        { x: -0.5, y: 0.5, z: 0.5 },
        { x: 0.5, y: 0.5, z: 0.5 },
        { x: 0.5, y: -0.5, z: 0.5 },

        { x: -0.5, y: -0.5, z: -0.5 },
        { x: -0.5, y: 0.5, z: -0.5 },
        { x: 0.5, y: 0.5, z: -0.5 },
        { x: 0.5, y: -0.5, z: -0.5 },
    ]

    const pathsIdx = [
        [0, 1, 2, 3, 0],
        [4, 5, 6, 7, 4],
        [0, 4],
        [1, 5],
        [2, 6],
        [3, 7],
    ]

    const clearCanvas = (canvas) => ctx.clearRect(0, 0, canvas.width, canvas.height);

    const depthScale = (depth) => 1 / Math.max(0.5, depth);

    const drawPoint = (p) => {
        ctx.fillStyle = "green";
        ctx.beginPath();
        ctx.arc(p.x, p.y, POINT_SIZE * depthScale(p.z), 0, 2 * Math.PI);
        ctx.fill();
    }

    const drawLine = (p1, p2) => {
        ctx.beginPath();
        ctx.lineWidth = STROKE_WIDTH * depthScale((p1.z + p2.z) / 2);
        ctx.strokeStyle = "green";
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
    }

    const drawFps = (secondsPassed) => {
        fps = Math.round(1 / secondsPassed);
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, 200, 100);
        ctx.font = '16px Arial';
        ctx.fillStyle = 'black';
        ctx.fillText("FPS: " + fps, 10, 20);
    }

    /**
     * Converts normalized device coordinates (NDC) to screen coordinates.
     * Maps x and y from [-1, 1] to [0, width] and [0, height], flipping Y for canvas.
     *
     * @param {{x:number,y:number,z:number}} p - Point in NDC space
     * @returns {{x:number,y:number,z:number}} Point in screen space with original depth
     */
    const viewport = (p, canvas) => {
        const width = canvas.width;
        const height = canvas.height;

        return {
            x: (p.x + 1) / 2 * width,
            y: (1 - (p.y + 1) / 2) * height,
            z: p.z,
        }
    }

    /**
     * Projects a 3D point onto a 2D plane using perspective projection.
     * Divides x and y by z to simulate depth (pinhole camera model).
     *
     * @param {{x:number,y:number,z:number}} p - 3D point to project
     * @returns {{x:number,y:number,z:number}} 2D projected point with original depth
     * @see https://en.wikipedia.org/wiki/3D_projection#Weak_perspective_projection
     */
    const perspectiveProject = (p) => {
        return {
            x: p.x / p.z,
            y: p.y / p.z,
            z: p.z
        }
    }

    /**
     * Rotates a 3D point around an arbitrary axis defined by two points using Rodrigues' rotation formula.
     *
     * @param {{x:number,y:number,z:number}} p - The point to rotate.
     * @param {{x:number,y:number,z:number}} a - First point defining the rotation axis.
     * @param {{x:number,y:number,z:number}} b - Second point defining the rotation axis.
     * @param {number} t - Rotation angle in radians.
     * @returns {{x:number,y:number,z:number}} The rotated point in 3D space.
     * 
     * @see https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula
     */
    const rotate = (p, a, b, t) => {
        let x = p.x - a.x, y = p.y - a.y, z = p.z - a.z;
        let u = b.x - a.x, v = b.y - a.y, w = b.z - a.z;
        const L = Math.hypot(u, v, w); u /= L; v /= L; w /= L;
        const ct = Math.cos(t), st = Math.sin(t), dot = u * x + v * y + w * z;
        return {
            x: a.x + u * dot * (1 - ct) + x * ct + (-w * y + v * z) * st,
            y: a.y + v * dot * (1 - ct) + y * ct + (w * x - u * z) * st,
            z: a.z + w * dot * (1 - ct) + z * ct + (-v * x + u * y) * st
        };
    };

    /**
     * Translates a 3D point by a given vector.
     *
     * @param {{x:number,y:number,z:number}} p - The original point.
     * @param {{x:number,y:number,z:number}} v - The translation vector.
     * @returns {{x:number,y:number,z:number}} The translated point.
     */
    const translatePoint = (p, v) => ({ x: p.x + v.x, y: p.y + v.y, z: p.z + v.z });

    const drawCube = (() => {
        const OFFSET_SPEED = 1;
        const ROTATION_SPEED = Math.PI;

        let offset = { x: 0, y: 0, z: 1 };
        let angle = 0;
        const v1 = { x: 0, y: 0, z: 0 }, v2 = { x: 1, y: 1, z: 0.5 };

        return (dt) => {
            offset = translatePoint(offset, { x: 0, y: 0, z: OFFSET_SPEED * dt });
            angle += ROTATION_SPEED * dt;

            const transformedPoints = points.map(p => viewport(perspectiveProject(translatePoint(rotate(p, v1, v2, angle), offset)), canvas));
            for (const tp of transformedPoints) drawPoint(tp);
            for (const idxMap of pathsIdx)
                for (let i = 0; i < idxMap.length - 1; i++)
                    drawLine(transformedPoints[idxMap[i]], transformedPoints[idxMap[i + 1]]);
        }
    })()

    let lastTs = 0;
    const render = (ts) => {
        if (!lastTs) { lastTs = ts; }
        const dt = Math.min((ts - lastTs) / 1000, 0.1);
        lastTs = ts;

        clearCanvas(canvas);
        drawFps(dt);
        drawCube(dt);

        requestAnimationFrame(render);
    };
    requestAnimationFrame(render);
</script>

</html>