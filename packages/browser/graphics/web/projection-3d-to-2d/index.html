<html>

<head>
    <style>
        html,
        body {
            border: none;
            margin: 0;
            padding: 0;
        }

        body {
            background-color: dimgray;
        }

        .centerContent {
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        #canvas {
            border-radius: 6px;
            border: 2px solid gray;
            background-color: white;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 5px;
            color: white;
        }

        .controls label {
            display: flex;
            justify-content: space-between;
        }

        input[type=number] {
            width: 60px;
        }
    </style>
</head>

<body>
    <div class="centerContent">
        <canvas id="canvas"></canvas>
        <div class="controls">
            <label>Offset Z: <input type="range" id="offsetZ" min="0" max="10" step="0.01" value="2"></label>
            <label><input type="checkbox" id="autoOffset"> Animate Z Offset</label>
            <label>Rotation Axis v1:
                X <input type="number" id="v1x" value="0" step="0.1">
                Y <input type="number" id="v1y" value="0" step="0.1">
                Z <input type="number" id="v1z" value="0" step="0.1">
            </label>
            <label>Rotation Axis v2:
                X <input type="number" id="v2x" value="1" step="0.1">
                Y <input type="number" id="v2y" value="1" step="0.1">
                Z <input type="number" id="v2z" value="0.5" step="0.1">
            </label>
            <input type="file" id="objLoader" accept=".obj">
        </div>
</body>
<script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const ASPECT_RATIO_WIDTH_TO_HEIGHT = 1;

    const resizeCanvas = () => {
        const MAX_PERCENTAGE = 0.8;
        const scale = Math.min(window.innerWidth * MAX_PERCENTAGE / ASPECT_RATIO_WIDTH_TO_HEIGHT, window.innerHeight * MAX_PERCENTAGE);
        canvas.width = scale * ASPECT_RATIO_WIDTH_TO_HEIGHT;
        canvas.height = scale;
    };

    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    const parseOBJ = (text) => {
        return text.split('\n').reduce((acc, line) => {
            const l = line.trim();
            if (l.startsWith('v ')) {
                const [, x, y, z] = l.split(/\s+/).map(Number);
                acc.vertices.push({ x, y, z });
            } else if (l.startsWith('f ')) {
                const idxs = l.split(/\s+/).slice(1).map(v => parseInt(v) - 1);
                acc.faces.push(idxs);
            }
            return acc;
        }, { vertices: [], faces: [] });
    };

    document.getElementById('objLoader').addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (file) {
            const text = await file.text();
            const objModel = parseOBJ(text);
            if (objModel.vertices.length > 0 && objModel.faces.length > 0) { model = objModel; }
        }
    });

    const POINT_SIZE = 20;
    const STROKE_WIDTH = 6;
    let model = {
        vertices: [
            { x: -0.5, y: -0.5, z: 0.5 }, { x: -0.5, y: 0.5, z: 0.5 },
            { x: 0.5, y: 0.5, z: 0.5 }, { x: 0.5, y: -0.5, z: 0.5 },
            { x: -0.5, y: -0.5, z: -0.5 }, { x: -0.5, y: 0.5, z: -0.5 },
            { x: 0.5, y: 0.5, z: -0.5 }, { x: 0.5, y: -0.5, z: -0.5 }
        ],
        faces: [
            [0, 1, 2, 3], [4, 5, 6, 7],
            [0, 1, 5, 4], [1, 2, 6, 5],
            [2, 3, 7, 6], [3, 0, 4, 7]
        ]
    };

    const clearCanvas = (canvas) => ctx.clearRect(0, 0, canvas.width, canvas.height);

    const depthScale = (depth) => 1 / Math.max(0.5, depth);

    const drawPoint = (p) => {
        ctx.fillStyle = "green";
        ctx.beginPath();
        ctx.arc(p.x, p.y, POINT_SIZE * depthScale(p.z), 0, 2 * Math.PI);
        ctx.fill();
    }

    const drawLine = (p1, p2) => {
        ctx.beginPath();
        ctx.lineWidth = STROKE_WIDTH * depthScale((p1.z + p2.z) / 2);
        ctx.strokeStyle = "green";
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
    }

    const drawFps = (secondsPassed) => {
        fps = Math.round(1 / secondsPassed);
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, 200, 100);
        ctx.font = '16px Arial';
        ctx.fillStyle = 'black';
        ctx.fillText("FPS: " + fps, 10, 20);
    }

    /**
     * Converts normalized device coordinates (NDC) to screen coordinates.
     * Maps x and y from [-1, 1] to [0, width] and [0, height], flipping Y for canvas.
     *
     * @param {{x:number,y:number,z:number}} p - Point in NDC space
     * @returns {{x:number,y:number,z:number}} Point in screen space with original depth
     */
    const viewport = (p, canvas) => {
        const width = canvas.width;
        const height = canvas.height;

        return {
            x: (p.x + 1) / 2 * width,
            y: (1 - (p.y + 1) / 2) * height,
            z: p.z,
        }
    }

    /**
     * Projects a 3D point onto a 2D plane using perspective projection.
     * Divides x and y by z to simulate depth (pinhole camera model).
     *
     * @param {{x:number,y:number,z:number}} p - 3D point to project
     * @returns {{x:number,y:number,z:number}} 2D projected point with original depth
     * @see https://en.wikipedia.org/wiki/3D_projection#Weak_perspective_projection
     */
    const perspectiveProject = (p) => {
        return {
            x: p.x / p.z,
            y: p.y / p.z,
            z: p.z
        }
    }

    /**
     * Rotates a 3D point around an arbitrary axis defined by two points using Rodrigues' rotation formula.
     *
     * @param {{x:number,y:number,z:number}} p - The point to rotate.
     * @param {{x:number,y:number,z:number}} a - First point defining the rotation axis.
     * @param {{x:number,y:number,z:number}} b - Second point defining the rotation axis.
     * @param {number} t - Rotation angle in radians.
     * @returns {{x:number,y:number,z:number}} The rotated point in 3D space.
     * 
     * @see https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula
     */
    const rotate = (p, a, b, t) => {
        let x = p.x - a.x, y = p.y - a.y, z = p.z - a.z;
        let u = b.x - a.x, v = b.y - a.y, w = b.z - a.z;
        const L = Math.hypot(u, v, w); u /= L; v /= L; w /= L;
        const ct = Math.cos(t), st = Math.sin(t), dot = u * x + v * y + w * z;
        return {
            x: a.x + u * dot * (1 - ct) + x * ct + (-w * y + v * z) * st,
            y: a.y + v * dot * (1 - ct) + y * ct + (w * x - u * z) * st,
            z: a.z + w * dot * (1 - ct) + z * ct + (-v * x + u * y) * st
        };
    };

    /**
     * Translates a 3D point by a given vector.
     *
     * @param {{x:number,y:number,z:number}} p - The original point.
     * @param {{x:number,y:number,z:number}} v - The translation vector.
     * @returns {{x:number,y:number,z:number}} The translated point.
     */
    const translatePoint = (p, v) => ({ x: p.x + v.x, y: p.y + v.y, z: p.z + v.z });

    const drawModel = (() => {
        const OFFSET_SPEED = 1;
        const ROTATION_SPEED = 1 / 2 * Math.PI;

        let offset = { x: 0, y: 0, z: 10 };
        let angle = 0;

        const v1Inputs = ['v1x', 'v1y', 'v1z']
        const v2Inputs = ['v2x', 'v2y', 'v2z'];
        const getV = (inputs) => ({ x: +document.getElementById(inputs[0]).value, y: +document.getElementById(inputs[1]).value, z: +document.getElementById(inputs[2]).value });
        const offsetSlider = document.getElementById('offsetZ')
        const autoOffsetCheckbox = document.getElementById('autoOffset');

        return (dt) => {
            if (autoOffsetCheckbox.checked) offset.z += 1 * dt;
            else offset.z = parseFloat(offsetSlider.value);

            const v1 = getV(v1Inputs);
            const v2 = getV(v2Inputs);
            angle += ROTATION_SPEED * dt;

            const transformed = model.vertices.map(p =>
                viewport(perspectiveProject(translatePoint(rotate(p, v1, v2, angle), offset)), canvas)
            );

            for (const p of transformed) drawPoint(p);
            for (const f of model.faces) {
                for (let i = 0; i < f.length; i++) {
                    const p1 = transformed[f[i]];
                    const p2 = transformed[f[(i + 1) % f.length]];
                    drawLine(p1, p2);
                }
            }
        }
    })()

    let lastTs = 0;
    const render = (ts) => {
        if (!lastTs) { lastTs = ts; }
        const dt = Math.min((ts - lastTs) / 1000, 0.1);
        lastTs = ts;

        clearCanvas(canvas);
        drawFps(dt);
        drawModel(dt);

        requestAnimationFrame(render);
    };
    requestAnimationFrame(render);
</script>

</html>